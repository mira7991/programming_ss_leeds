<!DOCTYPE html>
<html>
    <head>
        <title> Programming for Social Sciences </title>
            <style>
            body {
                margin: auto;
                background-color: rgb(34, 37, 38);  
                width: 1200px; 
                padding: 50px;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                word-spacing: 1px;
                line-height: 1.5;
                text-align: justify;
                color: #33475b;    
            }
            /* Centered Image Code */
            img {
                display: block;
                width: 40%;
                margin-left: auto;
                margin-right: auto;
            }
            h1   {color: whitesmoke; }
            h2   {color: whitesmoke; }
            h3   {color: whitesmoke; }
            p    {color: rgb(198, 183, 183);}
            
            </style>
    </head>
        <h1 style="text-align:center;"> Overview </h1>
        <hr /> 
        <p> This is a portfolio as a part of assessment for the  Programming for Social Sciences module, University of Leeds. There are 9 practicals which are designed to learn how to build simple Agent-based Model. 
            The practicals flow starts from creating agents with their location to making them interact with environment and each other. It also gives introduction on plotting and animating agents and environment. In the end the way how to perform web scraping is given. More details on each practical are provided below.</p>
        <hr /> 
        <h2 > Running the model </h2>
        <hr /> 
        <p> To run the model:
            <br> 1) Download/clone the  <a href = "https://github.com/mira7991/programming_ss_leeds" target = "_blank"> Github repository </a>
            <br> 2) Open the terminal/command line and change the current directory to the directory of the repository
            <br> 3) run python model.py [number of agents] [number of agents] [neighbourhood] [number of iterations]</p>
        <hr /> 
        <h2 style="text-align:center;"> Practical 1 </h2>
        <hr /> 
        <p> In this practical, the two agents are created and their y and x coordinates are set. They both begin at the same spot and move forward using random numbers. The final step is to compute the distance  between the agents. </p>
        <a href = "practical1_ABM_intro.py" target = "_blank"> Code </a>
        <hr />  
        <h2 style="text-align:center;"> Practical 2 </h2>
        <hr /> 
        <p> In this practical, we shrink the code from practical 1 by introducing containers, namely lists. So, now the agents' coordinates pairs are stored in the individual list which form nested list of all agents - [[y0,x0], [y1,x1]]. </p>
        <a href = "practical2_ABM_shrinked1.py"  target = "_blank"> Code </a>
        <br><p>The example of the expected output: </p>
        <img class="aligncenter" src="figures/practical2.png" alt="centered image" />
        <hr /> 
        <h2 style="text-align:center;"> Practical 3 </h2>
        <hr /> 
        <p>In this practical, we shrink the code from practical 2 by introducing control flow statement 'for'. We use it to create as many agents as we want (num_of_agents), and move them as many times as we like (num_of_iterations).  Also, we show two solutions to address edge issues - the case when the agents move too far away. First solution is solid wall setting - when the agent moves too far it's coord-s are reset to min boundary/max boundary. Second solution is torus - if agents moves away at the top/right,  it enters from bottom/left and the opposite.</p>
        <a href = "practical3_ABM_shrinked2.py"  target = "_blank"> Code </a>
        <br><p>The example of the expected output: </p>
        <img src="figures/practical3.png" />
        <hr /> 
        <h2 style="text-align:center;"> Practical 4 </h2>
        <hr /> 
        <p> This practical gives example of how to build a function. We build function to calculate distance between agents. Then with the for-loop we find the maximum distance between a pair of agents from the list. Also we time the code to check how long it takes to run it. </p>
        <a href = "practical4_building_tools.py" target = "_blank"> Code </a>
        <hr /> 
        <h2 style="text-align:center;"> Practical 5 </h2>
        <hr /> 
        <p> In this practical, we create and move agents around as in the previous practicals. However we make the objects, our agents, by using our template - Agent class - that is stored in the agentframework module and move the agents around using the class method '.move()'. The class has variables - randomly initialized x and y coordinates. Using classes helps to produce clean and easy to maintain code and is useful to build complicated system. </p>
        <a href = "practical5_agents.py" target = "_blank"> Code </a>
        <hr /> 
        <h2 style="text-align:center;"> Practical 6 </h2>
        <hr /> 
        <p>In this practical, we perform the followings:
            1) learn how to load data file - import raster data as our agents' environment;
            2) let our created agents interact with it- move around it, eat and and store eaten from the environment - using the Agent class methods stored in agentframework(more details about the methods in agentframework.py)
            3) we write out the changed environment to the file. </p>
        <a href = "practical6_io.py"  target = "_blank"> Code | </a>
        <a href = "data.txt"  target = "_blank"> Environment data | </a>
        <a href = "dataout.txt"  target = "_blank"> Resulting environment data </a>
        <br><p>The example of the expected output</p>
        <img src="figures/practical6.png" />
        <hr /> 
        <h2 style="text-align:center;"> Practical 7 </h2>
        <hr /> 
        <p>In this practical,  we perform the followings:
            1) as in the previous practical we import raster data as our agents' environment and let our created agents interact with it-move around it, eat and and store eaten- using the Agent class methods stored in agentframework.
            2) we let the agents communicate with each other and change each other variables using '.share_with_neighbours' method. This method looks for nearest neighbours of agent in specified distance from it and shares the food with them by splitting their total amount of food equally. More details of the method are given in the source code - agentframework.py
            3) introduce artifacts concept - patterns or mistakes that result from the model's operation, not from how well it represents reality -  and avoid them by randomizing the order=shuffling.</p>
        <a href = "practical7_communating.py" target = "_blank"> Code </a>
        <hr /> 
        <h2 style="text-align:center;"> Practical 8 </h2>
        <hr /> 
        <p>In this practical, we perform the followings:
            1) we animate our model using matplotlib.animatiion
            2) implement stopping condition based on how much the agent stores (the sheep has eaten)
            2) further improve the model by adding Offspring class(inherits the functionalities of the Agent) and Wolf class with functionalities to interact with other objects</p>
        <a href = "practical8_animation.py" target = "_blank"> Code </a>
        <br><p>The example of the expected output (one frame): </p>
        <img src="figures/practical8_start.png" />
        <hr /> 
        <h2 style="text-align:center;"> Practical 9 : Final Model Delivery </h2>
        <hr /> 
        <p>In this practical, we build Graphical User Interface (GUI) for our model to display it with menu to run, and perform web scraping - request some data into it from the web.</p>
        <a href = "model.py" target = "_blank"> Code | </a> 
        <a href = "env_out.txt"  target = "_blank"> Resulting environment data </a>
        <br><p>The example of the expected output - GUI when stopping condition is met - all agents are eaten: </p>
        <img src="figures/practical9.png" />
        <hr /> 
            <p style="font-size:12px ; "> MIT License
            <br> Copyright (c) 2022 mira7991
            <br>
            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated documentation files (the "Software"), to deal
            in the Software without restriction, including without limitation the rights
            to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
            copies of the Software, and to permit persons to whom the Software is
            furnished to do so, subject to the following conditions:
            
            The above copyright notice and this permission notice shall be included in all
            copies or substantial portions of the Software.
            
            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
            SOFTWARE.
         </p>

    </body>

</html>
